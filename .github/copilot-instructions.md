# GitHub Copilot – Blazor Component Instructions

These instructions define how GitHub Copilot should generate **C#**, **Razor**, **HTML**, and **CSS** inside this Blazor project.

They apply to all Copilot suggestions, completions, and Copilot Chat responses.

---

## 1. General Blazor Coding Rules

1. **Use semantic HTML** whenever possible:
   - `<main>`, `<section>`, `<header>`, `<footer>`, `<nav>`, `<article>`, `<button>`, etc.
2. **Do not use inline styles** (`style="..."`) except for extremely rare, unavoidable, runtime-only dynamic values.
3. Prefer **child components** over large `.razor` files.
4. Organize business logic in:
   - `@code` blocks for simple components, or
   - partial class `.razor.cs` code-behind files for complex logic.
5. Favor **readability and maintainability** over brevity.
6. Avoid unnecessary `<div>` nesting. Keep markup shallow.
7. Use **meaningful component names**: `UserCard`, `OrderList`, `ConfirmationDialog`.
8. User-visible text must be localized in resource files. Use english as default, and nb-NO for Norwegian Bokmål as secondary option.

---

## 2. CSS & Styling Rules

Important: All UI should look clean, modern, and consistent on both mobile and desktop browsers, using responsive layouts and typography. 

### CSS Isolation

All component-specific styling **must** be placed in `ComponentName.razor.css`.

Never put component-specific CSS in global files.

### Inline Styles (forbidden)

- Do **not** generate inline styles.
- Do **not** use `style="..."` attributes.
- Always use CSS classes.

### Naming Conventions

- Use a **BEM-like pattern**: `component-name`, `component-name__element`, `component-name--modifier`.
- Example:
  - `.user-card { }`
  - `.user-card__header { }`
  - `.user-card--highlighted { }`

### Responsive Layout

- Prefer **flexbox** or **CSS grid**.
- Avoid rigid pixel widths; use `rem`, `em`, `%`, or `max-width`.

### Utility Classes

Keep layout helpers such as spacing utilities or flex-grid helpers inside `wwwroot/css/site.css`.

---

## 3. Component Structure Requirements

### Required Files

A Blazor component generated by Copilot **must include**:

1. The `.razor` file.
2. A matching `.razor.css` file (if any visual structure exists).

### Razor Markup Rules

- Use semantic containers.
- Use `<button>` instead of clickable `<div>`.
- Use `<label>` paired with form inputs.
- Use attributes appropriately: `@bind-Value`, `@onclick`, `disabled`, `checked`, etc.
- Keep expressions simple inside markup; move complex logic to the code-behind.

### Dynamic Styling

Use **conditional classes**, not inline CSS:

```razor
<button class="@(isActive ? "btn btn--active" : "btn")">
```

### Parameters & Component APIs

- Use `[Parameter]` for all inputs.
- Use clear naming: `UserId`, `IsSelected`, `OnConfirmed`.
- When emitting callbacks, use `EventCallback` or `EventCallback<T>`.

---

## 4. C# Code Rules

Follow C# and Blazor best practices:

- Prefer dependency injection over static access.
- Place component logic in partial classes when it grows beyond ~30 lines.
- Make asynchronous code `async`/`await` (avoid `.Result` / `.Wait()`).
- Use `CancellationToken` where cancellation matters.
- Use latest syntax features (e.g., nullable reference types, expression-bodied members).
- Use latest language features (e.g., pattern matching, records) when appropriate.
- Use primary constructors.
- Use target-typed `new()` where appropriate.
- Write secure code.
 - Use structured logging via `ILogger<T>` and avoid swallowing exceptions.
 - Avoid unnecessary re-renders; use `@key`, keep `OnParametersSet` light, and consider `ShouldRender` for expensive components.

---

## 5. Accessibility Requirements

Copilot must ensure generated UI code includes:

- Proper labels for form fields:

```html
<label for="email">Email</label>
<input id="email" @bind="Email" />
```

- `aria-*` attributes for dynamic UI behavior when appropriate.
- Buttons use the `<button>` element, not `<div>`.
- Links use an `<a>` element with `href`.
- Images include `alt` text.

---

## 6. Documentation Expectations

For any non-trivial component, Copilot should include:

- XML documentation for public parameters and methods.
- Comments for complex logic.
- Summary comments for components describing purpose and behavior.

---

## 7. Example Output Pattern

When generating a component, Copilot should output two files.

### `UserCard.razor`

```razor
<section class="user-card">
    <header class="user-card__header">
        <img class="user-card__avatar" src="@AvatarUrl" alt="User avatar" />
        <div class="user-card__info">
            <h3>@Name</h3>
            <p>@Email</p>
        </div>
    </header>

    <button class="user-card__action" @onclick="OnViewProfile">
        View Profile
    </button>
</section>

@code {
    [Parameter] public string Name { get; set; } = string.Empty;
    [Parameter] public string Email { get; set; } = string.Empty;
    [Parameter] public string AvatarUrl { get; set; } = string.Empty;
    [Parameter] public EventCallback OnViewProfile { get; set; }
}
```

### `UserCard.razor.css`

```css
.user-card {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    padding: 1rem;
    border-radius: 0.5rem;
    background: var(--surface);
}

.user-card__header {
    display: flex;
    align-items: center;
    gap: 1rem;
}

.user-card__avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
}

.user-card__action {
    align-self: flex-start;
}
```

---

## 8. Goals & Enforcement

The purpose of these rules is to ensure:

- Consistent, accessible, maintainable Blazor UI components.
- Clean separation of markup, styling, and logic.
- Predictable output from GitHub Copilot.

Copilot must prioritize these guidelines over inferred patterns from existing code.

---

## 9. Yanitor Architecture & Domain Patterns

- **Single Blazor Server app**: The solution currently consists of `Yanitor.Web`, a Blazor Server app configured in `src/Yanitor.Web/Program.cs` using EF Core + SQLite (`Yanitor` connection string, defaulting to `Data Source=yanitor.db`).
- **Persistence model**: `YanitorDbContext` in `Data/YanitorDbContext.cs` defines EF entities `User`, `House`, `SelectedItemType`, and `ActiveTaskRow`. Domain types like `HouseItem`, `MaintenanceTask`, and `ActiveTask` live under `Domain/Models` and are mapped from EF rows in domain services (e.g., `ActiveTaskService.MapToDomain`). New persistence should follow this **EF-row + domain model** separation.
- **House configuration flow**: UI components (`HouseBuilder`, `MyHouse`) only talk to `IHouseConfigurationService`, `IItemProvider`, and `IActiveTaskService`. The concrete implementation `EfHouseConfigurationService` persists selected item types to `SelectedItemType` rows and then triggers `IActiveTaskService.SyncActiveTasksAsync()` to materialize `ActiveTaskRow` entries. New features must preserve this flow (UI → `IHouseConfigurationService` → EF + task sync) instead of writing directly to `YanitorDbContext` from components.
- **Default user and single-house assumption**: `EfHouseConfigurationService.EnsureDefaultUserAsync` creates a single dev user named `"Anders"` and a single `House` per user. Until multi-user support is implemented, all services assume **one logical house per dev**. Do not introduce multi-user assumptions without revisiting this helper and related queries.
- **Task generation & keys**: `ItemProvider` defines the canonical list of `HouseItem` instances and wires them to tasks via `ITaskProvider.GetTasksForItemType(HouseItemType)`. `ActiveTaskService.SyncActiveTasksAsync` treats `HouseItem.Name` and `MaintenanceTask.NameKey` as stable identifiers when creating `ActiveTaskRow` records. When adding new tasks or items:
    - Extend `HouseItemType`, `ItemProvider.InitializeItems`, and the corresponding domain resources (`Domain.Models.HouseItemResources.*.resx`).
    - Ensure `MaintenanceTask.NameKey`/`DescriptionKey` values are used as resource keys in `Domain.Services.TaskProvider.*.resx`.
    - Avoid persisting localized strings; always store keys and map to localized text via `IStringLocalizer`.
- **Immutable domain records**: Domain models like `ActiveTask` are C# `record` types with pure helpers (e.g., `MarkAsCompleted` returns a new instance). Prefer this pattern for new domain objects and keep side-effectful operations in services.

---

## 10. Localization, Routing, and UI Conventions

- **Culture from route + cookie**: `Program.cs` configures `RequestLocalizationOptions` with custom `RouteDataRequestCultureProvider` and also query-string, cookie, and `Accept-Language` providers. All top-level pages use **two route templates**, e.g. `@page "/my-house"` and `@page "/{culture}/my-house"`. New pages must follow this pattern so culture can be injected via route values.
- **Resource structure**: UI components use `IStringLocalizer<TComponent>` with resources under `Resources/Components.Pages.*.resx`. Domain- and service-level strings live in `Domain.*.resx`, and shared/global strings in `SharedResources.*.resx`. When adding user-visible text:
    - Add keys to the relevant `.resx` file for `en` and `nb-NO` (and optionally the neutral `.resx` fallback).
    - Use the existing key naming patterns, e.g. `ItemType_Ventilation_Name`, `Item_Ventilation System_Name`, or `Task_SomeKey_Title`.
- **Culture-aware navigation**: Components such as `MyHouse` and `ActiveTasks` construct URLs that preserve the optional culture segment (see `GetActiveTasksUrl`, `GetMyHouseUrl`). New navigation helpers should follow the same pattern: derive URLs from the current `Culture` parameter when present and fall back to culture-less routes.
- **Interactive render mode**: All interactive pages (`MyHouse`, `HouseBuilder`, `ActiveTasks`, etc.) use `@rendermode InteractiveServer`. New interactive components should do the same unless there is a specific reason to use a different render mode.

---

## 11. Build, Database, and Migrations Workflow

- **Running locally**: From the repo root, run `dotnet run --project src/Yanitor.Web/Yanitor.Web.csproj`. On startup, `Program.cs` creates a scope and calls `db.Database.MigrateAsync()`, applying pending EF Core migrations to the SQLite database file.
- **Migrations**: When changing EF entities in `YanitorDbContext.cs`, add a migration in the `src/Yanitor.Web` project, for example:

    ```bash
    dotnet ef migrations add <Name> --project src/Yanitor.Web --startup-project src/Yanitor.Web
    dotnet ef database update --project src/Yanitor.Web --startup-project src/Yanitor.Web
    ```

    Keep migrations in `src/Yanitor.Web/Migrations` and avoid editing generated migration code manually unless necessary.
- **Seeding and test data**: The app currently boots with a single default user and no explicit seed data beyond `ItemProvider`'s in-memory definitions. If additional seed data is required, prefer **idempotent seeding in a domain service or a dedicated initializer** invoked at startup, rather than hardcoding values directly into components.

---

## 12. Unit Testing

If C# code has logic that should be unit tested, Copilot should generate or extend a corresponding test project using xUnit (e.g., a `Yanitor.Tests` project at the solution root) and follow the existing domain/service boundaries (test `Domain.Services` and `Domain.Models` rather than UI markup where possible).

---

## 13. Permissions

- You are allowed to run all `dotnet` commands necessary to build, test, and run the Blazor project.
- You are allowed to read any file in the repository to understand context.
- You are allowed to read output of commands and tests.
