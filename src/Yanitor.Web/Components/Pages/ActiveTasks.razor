@page "/active-tasks"
@page "/{culture}/active-tasks"
@using System.Globalization
@using Microsoft.AspNetCore.Components.Web
@using Microsoft.Extensions.Localization
@using Yanitor.Web.Domain
@using Yanitor.Web.Domain.Models
@using Yanitor.Web.Domain.Services
@using Yanitor.Web.Components
@inject IStringLocalizer<ActiveTasks> L
@inject IStringLocalizer<HouseItemResources> ItemL
@inject IStringLocalizer<TaskProvider> TaskL
@inject NavigationManager Navigation
@inject IActiveTaskService TaskService
@rendermode InteractiveServer

<PageTitle>@L["PageTitle"]</PageTitle>

<section class="active-tasks">
    <header class="active-tasks__header">
        <a href="@GetMyHouseUrl()" class="active-tasks__back-button" aria-label="@L["BackToMyHouse"]">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M19 12H5M12 19l-7-7 7-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
        </a>
        <div class="active-tasks__header-content">
            <h1 class="active-tasks__title">@L["PageTitle"]</h1>
            <p class="active-tasks__subtitle">@L["Subtitle"]</p>
        </div>
    </header>

    @if (_isLoading)
    {
        <div class="active-tasks__loading">
            <p>@L["Loading"]</p>
        </div>
    }
    else if (!_tasks.Any())
    {
        <div class="active-tasks__empty">
            <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                <path d="M9 11l3 3L22 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
            </svg>
            <p>@L["NoTasks"]</p>
        </div>
    }
    else
    {
        @if (_overdueTasks.Any())
        {
            <section class="active-tasks__section active-tasks__section--overdue">
                <h2 class="active-tasks__section-title">@L["OverdueTasks"] (@_overdueTasks.Count())</h2>
                <div class="active-tasks__list">
                    @foreach (var task in _overdueTasks)
                    {
                        @RenderTaskCard(task, "overdue")
                    }
                </div>
            </section>
        }

        @if (_dueSoonTasks.Any())
        {
            <section class="active-tasks__section active-tasks__section--due-soon">
                <h2 class="active-tasks__section-title">@L["DueSoon"] (@_dueSoonTasks.Count())</h2>
                <div class="active-tasks__list">
                    @foreach (var task in _dueSoonTasks)
                    {
                        @RenderTaskCard(task, "due-soon")
                    }
                </div>
            </section>
        }

        @if (_upcomingTasks.Any())
        {
            <section class="active-tasks__section">
                <h2 class="active-tasks__section-title">@L["UpcomingTasks"] (@_upcomingTasks.Count())</h2>

                @if (_availableItemTypes.Any())
                {
                    <nav class="active-tasks__filters" aria-label="@L["FilterByItemType"]">
                        <button type="button"
                                class="@GetFilterPillClass(null)"
                                @onclick="() => SetItemTypeFilter(null)">
                            @L["Filter_All"]
                        </button>

                        @foreach (var itemType in _availableItemTypes)
                        {
                            <button type="button"
                                    class="@GetFilterPillClass(itemType)"
                                    @onclick="() => SetItemTypeFilter(itemType)">
                                @ItemL[$"ItemType_{itemType}_Name"]
                            </button>
                        }
                    </nav>
                }

                <div class="active-tasks__list">
                    @foreach (var task in _upcomingTasks)
                    {
                        @RenderTaskCard(task, "")
                    }
                </div>
            </section>
        }
    }
</section>

@code {
    [Parameter]
    public string? Culture { get; set; }

    private bool _isLoading = true;
    private List<ActiveTask> _tasks = new();
    private IEnumerable<ActiveTask> _overdueTasks = Enumerable.Empty<ActiveTask>();
    private IEnumerable<ActiveTask> _dueSoonTasks = Enumerable.Empty<ActiveTask>();
    private IEnumerable<ActiveTask> _upcomingTasks = Enumerable.Empty<ActiveTask>();
    private IReadOnlyList<HouseItemType> _availableItemTypes = Array.Empty<HouseItemType>();
    private HouseItemType? _selectedItemTypeFilter = null;
    private Guid? _editingTaskId = null;
    private string _editingDateValue = "";

    protected override async Task OnInitializedAsync()
    {
        await LoadTasksAsync();
    }

    private async Task LoadTasksAsync()
    {
        _isLoading = true;
        _tasks = (await TaskService.GetActiveTasksAsync()).ToList();

        RecalculateTaskBuckets();

        _isLoading = false;
    }

    private async Task CompleteTask(Guid taskId)
    {
        await TaskService.CompleteTaskAsync(taskId);
        await LoadTasksAsync();
        StateHasChanged();
    }

    private string GetMyHouseUrl()
    {
        return string.IsNullOrWhiteSpace(Culture)
            ? "/my-house"
            : $"/{Culture}/my-house";
    }

    private string GetDaysUntilDueText(int days)
    {
        if (days == 0)
            return L["DueToday"];
        if (days == 1)
            return L["DueTomorrow"];

        return L["DueInDays", days];
    }

    private void RecalculateTaskBuckets()
    {
        _availableItemTypes = _tasks
            .Select(t => t.Item.ItemType)
            .Distinct()
            .OrderBy(t => t.ToString())
            .ToList();

        IEnumerable<ActiveTask> query = _tasks;
        if (_selectedItemTypeFilter.HasValue)
        {
            query = query.Where(t => t.Item.ItemType == _selectedItemTypeFilter.Value);
        }

        _overdueTasks = query.Where(t => t.IsOverdue).OrderBy(t => t.NextDueDate);
        _dueSoonTasks = query.Where(t => t.IsDueSoon && !t.IsOverdue).OrderBy(t => t.NextDueDate);
        _upcomingTasks = query.Where(t => !t.IsOverdue && !t.IsDueSoon).OrderBy(t => t.NextDueDate);
    }

    private void SetItemTypeFilter(HouseItemType? itemType)
    {
        _selectedItemTypeFilter = itemType;
        RecalculateTaskBuckets();
    }

    private string GetFilterPillClass(HouseItemType? itemType)
    {
        var isAllPill = !itemType.HasValue;
        var isFilterAll = !_selectedItemTypeFilter.HasValue;

        var isActive = (isAllPill && isFilterAll) ||
                       (!isAllPill && _selectedItemTypeFilter.HasValue && _selectedItemTypeFilter.Value.Equals(itemType!.Value));

        return isActive
            ? "active-tasks__filter-pill active-tasks__filter-pill--active"
            : "active-tasks__filter-pill";
    }


    private RenderFragment RenderTaskCard(ActiveTask task, string modifierClass) => __builder =>
    {
        var cardClass = string.IsNullOrWhiteSpace(modifierClass) 
            ? "active-tasks__card" 
            : $"active-tasks__card active-tasks__card--{modifierClass}";
        var badgeClass = string.IsNullOrWhiteSpace(modifierClass)
            ? "active-tasks__card-badge"
            : $"active-tasks__card-badge active-tasks__card-badge--{modifierClass}";
        
        var daysNumber = Math.Abs(task.DaysUntilDue);
        var daysText = task.IsOverdue 
            ? (daysNumber == 1 ? L["Day"] : L["Days"]) 
            : (task.DaysUntilDue == 0 ? L["Today"] : task.DaysUntilDue == 1 ? L["Tomorrow"] : L["Days"]);

        // Resolve item display from domain localizers (room name is user-entered; do not localize)
        var itemSpecificKey = $"Item_{task.Item.Name}_Name";
        var itemTypeKey = $"ItemType_{task.Item.ItemType}_Name";
        var localizedItemName = ItemL[itemSpecificKey];
        if (localizedItemName.ResourceNotFound || string.IsNullOrWhiteSpace(localizedItemName.Value))
        {
            localizedItemName = ItemL[itemTypeKey];
        }
        var displayItemName = (!localizedItemName.ResourceNotFound && !string.IsNullOrWhiteSpace(localizedItemName.Value)) ? localizedItemName.Value : task.Item.Name;

        // Resolve task title/description using keys from MaintenanceTask
        var displayTaskName = TaskL[task.Task.NameKey];
        var displayTaskDescription = TaskL[task.Task.DescriptionKey];
        var taskNameValue = (!displayTaskName.ResourceNotFound && !string.IsNullOrWhiteSpace(displayTaskName.Value)) ? displayTaskName.Value : task.Task.NameKey;
        var taskDescValue = (!displayTaskDescription.ResourceNotFound && !string.IsNullOrWhiteSpace(displayTaskDescription.Value)) ? displayTaskDescription.Value : task.Task.DescriptionKey;
        var dueDateText = L["DueOn", task.NextDueDate.ToLocalTime().ToString("d")];
        
        <article class="@cardClass">
            <div class="@badgeClass">
                <span class="active-tasks__card-badge-number">@daysNumber</span>
                <span class="active-tasks__card-badge-text">@daysText</span>
                @if (task.IsOverdue)
                {
                    <span class="active-tasks__card-badge-label">@L["Overdue"]</span>
                }
            </div>
            
            <div class="active-tasks__card-header">
                <div class="active-tasks__card-icon">
                    <Yanitor.Web.Components.IconFactory Item="task.Item" />
                </div>
                <div class="active-tasks__card-info">
                    <p class="active-tasks__card-item">@displayItemName</p>
                    <h3 class="active-tasks__card-title">@taskNameValue</h3>
                </div>
            </div>
            <p class="active-tasks__card-description">@taskDescValue</p>
            <p class="active-tasks__card-due-date">@dueDateText</p>
            
            @if (_editingTaskId == task.Id)
            {
                <div class="active-tasks__date-picker">
                    <label for="date-@task.Id" class="active-tasks__date-picker-label">@L["SetCompletionDate"]</label>
                    <div class="active-tasks__date-picker-controls">
                        <input 
                            type="date" 
                            id="date-@task.Id"
                            class="active-tasks__date-picker-input" 
                            value="@_editingDateValue"
                            @oninput="@(e => _editingDateValue = e.Value?.ToString() ?? "")"
                            max="@DateTime.Now.ToString("yyyy-MM-dd")" />
                        <button type="button" class="active-tasks__date-picker-button active-tasks__date-picker-button--save" @onclick="() => SaveCompletionDate(task.Id)">
                            @L["Save"]
                        </button>
                        <button type="button" class="active-tasks__date-picker-button active-tasks__date-picker-button--cancel" @onclick="CancelEditDate">
                            @L["Cancel"]
                        </button>
                    </div>
                </div>
            }
            else if (task.LastCompletedAt.HasValue)
            {
                <button type="button" class="active-tasks__card-last-completed active-tasks__card-last-completed--clickable"
                        @onclick="() => StartEditingDate(task.Id, task.LastCompletedAt.Value)"
                        title="@L["ClickToEditDate"]">
                    @L["LastCompleted", task.LastCompletedAt.Value.ToLocalTime().ToString("d")]
                    <svg class="active-tasks__edit-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            }
            else
            {
                <button type="button" class="active-tasks__card-last-completed active-tasks__card-last-completed--never active-tasks__card-last-completed--clickable"
                        @onclick="() => StartEditingDate(task.Id, null)"
                        title="@L["ClickToSetDate"]">
                    @L["NeverCompleted"]
                    <svg class="active-tasks__edit-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                        <path d="M11 4H4a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2v-7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        <path d="M18.5 2.5a2.121 2.121 0 013 3L12 15l-4 1 1-4 9.5-9.5z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            }
            
            <div class="active-tasks__card-footer">
                <button type="button" class="active-tasks__card-button" @onclick="() => CompleteTask(task.Id)">
                    @L["MarkComplete"]
                </button>
            </div>
        </article>
    };

    private void StartEditingDate(Guid taskId, DateTime? currentDate)
    {
        _editingTaskId = taskId;
        _editingDateValue = currentDate?.ToLocalTime().ToString("yyyy-MM-dd") ?? DateTime.Now.ToString("yyyy-MM-dd");
    }

    private void CancelEditDate()
    {
        _editingTaskId = null;
        _editingDateValue = "";
    }

    private async Task SaveCompletionDate(Guid taskId)
    {
        if (DateTime.TryParse(_editingDateValue, out var selectedDate))
        {
            var utcDate = selectedDate.ToUniversalTime();
            await TaskService.CompleteTaskAsync(taskId, utcDate);
            _editingTaskId = null;
            _editingDateValue = "";
            await LoadTasksAsync();
            StateHasChanged();
        }
    }
}
